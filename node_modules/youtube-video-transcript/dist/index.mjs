var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../youtube-video-core/node_modules/tiny-cors-proxy/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  corsServer: () => corsServer,
  createRateLimitChecker: () => createRateLimitChecker,
  createServer: () => createServer,
  default: () => src_default
});
function isValidHostName(hostname) {
  return !!(net.isIPv4(hostname) || net.isIPv6(hostname));
}
function withCORS(headers, request) {
  headers["access-control-allow-origin"] = "*";
  const corsMaxAge = request.corsProxyRequestState.corsMaxAge;
  if (request.method === "OPTIONS" && corsMaxAge) {
    headers["access-control-max-age"] = corsMaxAge.toString();
  }
  if (request.headers["access-control-request-method"]) {
    headers["access-control-allow-methods"] = request.headers["access-control-request-method"];
    delete request.headers["access-control-request-method"];
  }
  if (request.headers["access-control-request-headers"]) {
    headers["access-control-allow-headers"] = request.headers["access-control-request-headers"];
    delete request.headers["access-control-request-headers"];
  }
  headers["access-control-expose-headers"] = Object.keys(headers).join(",");
  return headers;
}
function parseURL(req_url) {
  const match2 = req_url.match(/^(?:(https?:)?\/\/)?(([^\/?]+?)(?::(\d{0,5})(?=[\/?]|$))?)([\/?][\S\s]*|$)/i);
  if (!match2) {
    return null;
  }
  if (!match2[1]) {
    if (/^https?:/i.test(req_url)) {
      return null;
    }
    req_url = (match2[4] === "443" ? "https:" : "http:") + "//" + req_url;
  }
  const parsed = url.parse(req_url);
  if (!parsed.hostname) {
    return null;
  }
  return parsed;
}
function onProxyResponse(proxy, proxyReq, proxyRes, req, res) {
  const requestState = req.corsProxyRequestState;
  const statusCode = proxyRes.statusCode;
  if (!requestState.redirectCount_) {
    res.setHeader("x-request-url", requestState.location.href);
  }
  if (statusCode === 301 || statusCode === 302 || statusCode === 303 || statusCode === 307 || statusCode === 308) {
    let locationHeader = proxyRes.headers.location;
    let parsedLocation = null;
    if (locationHeader) {
      locationHeader = url.resolve(requestState.location.href, locationHeader);
      parsedLocation = parseURL(locationHeader);
    }
    if (parsedLocation) {
      if (statusCode === 301 || statusCode === 302 || statusCode === 303) {
        requestState.redirectCount_ = (requestState.redirectCount_ || 0) + 1;
        if (requestState.redirectCount_ <= requestState.maxRedirects) {
          res.setHeader("X-CORS-Redirect-" + requestState.redirectCount_, `${statusCode} ${locationHeader}`);
          req.method = "GET";
          req.headers["content-length"] = "0";
          delete req.headers["content-type"];
          requestState.location = parsedLocation;
          req.removeAllListeners();
          proxyReq.removeAllListeners("error");
          proxyReq.once("error", function catchAndIgnoreError() {
          });
          proxyReq.abort();
          proxyRequest(req, res, proxy);
          return false;
        }
      }
      proxyRes.headers.location = `${requestState.proxyBaseUrl}/${locationHeader}`;
    }
  }
  delete proxyRes.headers["set-cookie"];
  delete proxyRes.headers["set-cookie2"];
  proxyRes.headers["x-final-url"] = requestState.location.href;
  withCORS(proxyRes.headers, req);
  return true;
}
function proxyRequest(req, res, proxy) {
  const location = req.corsProxyRequestState.location;
  req.url = location.path;
  const proxyOptions = {
    changeOrigin: false,
    prependPath: false,
    toProxy: false,
    target: location,
    headers: {
      host: location.host
    },
    buffer: {
      pipe(proxyReq) {
        const proxyReqOn = proxyReq.on;
        proxyReq.on = function(eventName, listener) {
          if (eventName !== "response") {
            return proxyReqOn.call(this, eventName, listener);
          }
          return proxyReqOn.call(this, "response", function(proxyRes) {
            if (onProxyResponse(proxy, proxyReq, proxyRes, req, res)) {
              try {
                listener(proxyRes);
              } catch (err) {
                proxyReq.emit("error", err);
              }
            }
          });
        };
        return req.pipe(proxyReq);
      }
    }
  };
  const proxyThroughUrl = req.corsProxyRequestState.getProxyForUrl(location.href);
  if (proxyThroughUrl) {
    proxyOptions.target = proxyThroughUrl;
    proxyOptions.toProxy = true;
    req.url = location.href;
  }
  try {
    proxy.web(req, res, proxyOptions);
  } catch (err) {
    proxy.emit("error", err, req, res);
  }
}
function getHandler(options, proxy) {
  const corsProxy = {
    handleInitialRequest: null,
    getProxyForUrl,
    maxRedirects: 5,
    originBlacklist: [],
    originWhitelist: [],
    checkRateLimit: null,
    redirectSameOrigin: false,
    requireHeader: null,
    removeHeaders: [],
    setHeaders: {},
    corsMaxAge: 0,
    ...options
  };
  if (corsProxy.requireHeader) {
    if (typeof corsProxy.requireHeader === "string") {
      corsProxy.requireHeader = [corsProxy.requireHeader.toLowerCase()];
    } else if (!Array.isArray(corsProxy.requireHeader) || corsProxy.requireHeader.length === 0) {
      corsProxy.requireHeader = null;
    } else {
      corsProxy.requireHeader = corsProxy.requireHeader.map(function(headerName) {
        return headerName.toLowerCase();
      });
    }
  }
  const hasRequiredHeaders = function(headers) {
    return !corsProxy.requireHeader || Array.isArray(corsProxy.requireHeader) && corsProxy.requireHeader.some((headerName) => Object.hasOwnProperty.call(headers, headerName));
  };
  return function(req, res) {
    req.corsProxyRequestState = {
      getProxyForUrl: corsProxy.getProxyForUrl,
      maxRedirects: corsProxy.maxRedirects,
      corsMaxAge: corsProxy.corsMaxAge
    };
    const cors_headers = withCORS({}, req);
    if (req.method === "OPTIONS") {
      res.writeHead(200, cors_headers);
      res.end();
      return;
    }
    const location = parseURL(req.url.slice(1));
    if (corsProxy.handleInitialRequest && corsProxy.handleInitialRequest(req, res, location)) {
      return;
    }
    if (!location) {
      if (/^\/https?:\/[^/]/i.test(req.url)) {
        res.writeHead(400, "Missing slash", cors_headers);
        res.end("The URL is invalid: two slashes are needed after the http(s):.");
        return;
      }
      res.writeHead(200, cors_headers);
      res.end();
      return;
    }
    if (location.host === "iscorsneeded") {
      res.writeHead(200, { "Content-Type": "text/plain" });
      res.end("no");
      return;
    }
    if (location.port > "65535") {
      res.writeHead(400, "Invalid port", cors_headers);
      res.end("Port number too large: " + location.port);
      return;
    }
    if (!/^\/https?:/.test(req.url) && !isValidHostName(location.hostname)) {
      res.writeHead(404, "Invalid host", cors_headers);
      res.end("Invalid host: " + location.hostname);
      return;
    }
    if (!hasRequiredHeaders(req.headers)) {
      res.writeHead(400, "Header required", cors_headers);
      res.end("Missing required request header. Must specify one of: " + corsProxy.requireHeader);
      return;
    }
    const origin = req.headers.origin || "";
    if (corsProxy.originBlacklist.indexOf(origin) >= 0) {
      res.writeHead(403, "Forbidden", cors_headers);
      res.end('The origin "' + origin + '" was blacklisted by the operator of this proxy.');
      return;
    }
    if (corsProxy.originWhitelist.length && corsProxy.originWhitelist.indexOf(origin) === -1) {
      res.writeHead(403, "Forbidden", cors_headers);
      res.end('The origin "' + origin + '" was not whitelisted by the operator of this proxy.');
      return;
    }
    const rateLimitMessage = corsProxy.checkRateLimit && corsProxy.checkRateLimit(origin);
    if (rateLimitMessage) {
      res.writeHead(429, "Too Many Requests", cors_headers);
      res.end('The origin "' + origin + '" has sent too many requests.\n' + rateLimitMessage);
      return;
    }
    if (corsProxy.redirectSameOrigin && origin && location.href[origin.length] === "/" && location.href.lastIndexOf(origin, 0) === 0) {
      cors_headers.vary = "origin";
      cors_headers["cache-control"] = "private";
      cors_headers.location = location.href;
      res.writeHead(301, "Please use a direct request", cors_headers);
      res.end();
      return;
    }
    const isRequestedOverHttps = req.connection.encrypted || /^\s*https/.test(req.headers["x-forwarded-proto"]);
    const proxyBaseUrl = (isRequestedOverHttps ? "https://" : "http://") + req.headers.host;
    corsProxy.removeHeaders.forEach(function(header) {
      delete req.headers[header];
    });
    Object.keys(corsProxy.setHeaders).forEach(function(header) {
      req.headers[header] = corsProxy.setHeaders[header];
    });
    req.corsProxyRequestState.location = location;
    req.corsProxyRequestState.proxyBaseUrl = proxyBaseUrl;
    proxyRequest(req, res, proxy);
  };
}
function createServer(options) {
  options = options || {};
  const httpProxyOptions = {
    xfwd: true,
    secure: process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0"
  };
  if (options.httpProxyOptions) {
    Object.keys(options.httpProxyOptions).forEach(function(option) {
      httpProxyOptions[option] = options.httpProxyOptions[option];
    });
  }
  const proxy = httpProxy.createServer(httpProxyOptions);
  const requestHandler = getHandler(options, proxy);
  let server;
  if (options.httpsOptions) {
    server = https.createServer(options.httpsOptions, requestHandler);
  } else {
    server = http.createServer(requestHandler);
  }
  proxy.on("error", function(err, req, res) {
    if (res.headersSent) {
      if (res.writableEnded === false) {
        res.end();
      }
      return;
    }
    const headerNames = res.getHeaderNames ? res.getHeaderNames() : Object.keys(res._headers || {});
    headerNames.forEach(function(name) {
      res.removeHeader(name);
    });
    res.writeHead(404, { "Access-Control-Allow-Origin": "*" });
    res.end("Not found because of proxy error: " + err);
  });
  return server;
}
function createRateLimitChecker(limit) {
  const rateLimitConfig = /^(\d+) (\d+)(?:\s*$|\s+(.+)$)/.exec(limit);
  if (!rateLimitConfig) {
    return (origin) => null;
  }
  const maxRequestsPerPeriod = parseInt(rateLimitConfig[1]);
  const periodInMinutes = parseInt(rateLimitConfig[2]);
  let unlimitedPattern;
  const unlimitedPatternString = rateLimitConfig[3];
  if (unlimitedPatternString) {
    const unlimitedPatternParts = unlimitedPatternString.trim().split(/\s+/).map((unlimitedHost) => {
      if (unlimitedHost.startsWith("/") && unlimitedHost.endsWith("/")) {
        const regexPattern = unlimitedHost.slice(1, -1);
        return new RegExp(regexPattern, "i");
      } else {
        return unlimitedHost.replace(/[$()*+.?[\\\]^{|}]/g, "\\$&");
      }
    });
    const joinedPattern = unlimitedPatternParts.join("|");
    unlimitedPattern = new RegExp(`^(?:${joinedPattern})$`, "i");
  }
  const accessedHosts = {};
  setInterval(() => {
    Object.keys(accessedHosts).forEach((host) => {
      delete accessedHosts[host];
    });
  }, periodInMinutes * 6e4);
  const rateLimitMessage = `The number of requests is limited to ${maxRequestsPerPeriod} per ${periodInMinutes === 1 ? "minute" : periodInMinutes + " minutes"}. Please self-host CORS Anywhere if you need more quota. See https://github.com/Rob--W/cors-anywhere#demo-server`;
  return function checkRateLimit(origin) {
    const host = origin.replace(/^[\w\-]+:\/\//i, "");
    if (unlimitedPattern && unlimitedPattern.test(host)) {
      return null;
    }
    const count = accessedHosts[host] || 0;
    accessedHosts[host] = count + 1;
    if (count + 1 > maxRequestsPerPeriod) {
      return rateLimitMessage;
    }
    return null;
  };
}
var __require2, net, url, httpProxy, http, https, getProxyForUrl, corsServer, src_default;
var init_dist = __esm({
  "../youtube-video-core/node_modules/tiny-cors-proxy/dist/index.mjs"() {
    __require2 = /* @__PURE__ */ ((x) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x, {
      get: (a, b) => (typeof __require !== "undefined" ? __require : a)[b]
    }) : x)(function(x) {
      if (typeof __require !== "undefined")
        return __require.apply(this, arguments);
      throw Error('Dynamic require of "' + x + '" is not supported');
    });
    net = null;
    url = null;
    httpProxy = null;
    http = null;
    https = null;
    getProxyForUrl = null;
    if (typeof module !== "undefined" && module.exports) {
      net = __require2("net");
      url = __require2("url");
      httpProxy = __require2("http-proxy");
      http = __require2("http");
      https = __require2("https");
      getProxyForUrl = __require2("proxy-from-env").getProxyForUrl;
    }
    corsServer = createServer({
      originWhitelist: [],
      // Allow all origins
      requireHeader: ["origin", "x-requested-with"],
      removeHeaders: ["cookie", "cookie2"]
    });
    src_default = corsServer;
  }
});

// ../youtube-video-core/src/constants.ts
var YoutubeUrl = "https://www.youtube.com/watch";
var RegexExtractYoutubeVideoId = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i;
var RegexExtractFromXml = /<text start="([^"]*)" dur="([^"]*)">([^<]*)<\/text>/g;
var RegexExtractMetadataPlayer = /var\s+ytInitialPlayerResponse\s*=\s*({.*?});/s;
var RegexExtractMetadata = /var\s+ytInitialData\s*=\s*({.*?});/s;
var RegexExtractYoutubeVideoIdFromShortUrl = /(?:youtube\.com\/shorts\/)([a-zA-Z0-9_-]+)/;
var UserAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36,gzip(gfe)";

// src/transcription.ts
var TranscriptionList = class {
  constructor(transcriptions) {
    this.transcriptions = [];
    this.transcriptions = transcriptions;
  }
  list() {
    return this.transcriptions;
  }
  getManual() {
    return this.transcriptions.find((t) => t.type == "manual");
  }
  getAuto() {
    return this.transcriptions.find((t) => t.type == "auto");
  }
  get(language) {
    return this.transcriptions.find((t) => t.language == language);
  }
  getMultiple(languages) {
    return this.transcriptions.filter((t) => languages.includes(t.language));
  }
};

// ../youtube-video-core/src/errors.ts
var TranscriptionDisabledError = class extends Error {
  constructor() {
    super("Transcription is disabled for this video");
  }
};
var MetricNotAvaible = class extends Error {
  constructor() {
    super("Metric is not available for this video");
  }
};
var VideoUnavailableError = class extends Error {
  constructor() {
    super("Video is unavailable");
  }
};
var InvalidVideoUrlError = class extends Error {
  constructor() {
    super("Invalid video url");
  }
};
var InvalidLanguageError = class extends Error {
  constructor() {
    super("Invalid language");
  }
};
var TooManyRequestsError = class extends Error {
  constructor() {
    super("Too many requests");
  }
};
var LanguageNotAvailableError = class extends Error {
  constructor() {
    super("Language not available");
  }
};

// ../youtube-video-core/src/utils.ts
var match = (str, regex) => {
  const result = str.match(regex);
  return result ? result[1] : null;
};
var isBrowser = () => typeof module === "undefined" || !module.exports;

// ../youtube-video-core/src/proxy.ts
var Proxy2 = class {
  constructor() {
    this.isProxyTested = false;
    this._isProxyAvailable = false;
    this.proxyHeaders = {};
    this.proxyUrl = "";
  }
  async isProxyAvailable() {
    if (this.isProxyTested == false) {
      try {
        await fetch(this.proxyUrl);
        this._isProxyAvailable = true;
      } finally {
        this.isProxyTested = true;
      }
    }
    return this._isProxyAvailable;
  }
  setProxy(options) {
    var _a;
    this.proxyUrl = options.url;
    this.proxyHeaders = (_a = options.headers) != null ? _a : {};
    if (!this.proxyHeaders["X-Requested-With"])
      this.proxyHeaders["X-Requested-With"] = "XMLHttpRequest";
    this.isProxyTested = false;
  }
  async fetchThroughtProxy(url2, option, isProxy = false) {
    if (isProxy && await this.isProxyAvailable()) {
      url2 = `${this.proxyUrl}${url2}`;
      if (option.headers === void 0)
        option.headers = {};
      option.headers = { ...option.headers, ...this.proxyHeaders };
    }
    return fetch(url2, option);
  }
};

// ../youtube-video-core/src/core.ts
var Core = class {
  constructor() {
    this.proxy = new Proxy2();
  }
  /**
   * Fetch video page
   * @param videoId Video id
   */
  async fetchVideo(videoId) {
    return await this.fetchHtml(videoId);
  }
  setProxy(options) {
    this.proxy.setProxy(options);
    return this;
  }
  async fetchHtml(videoId) {
    const headers = { "User-Agent": UserAgent, "Accept-Language": "en-US" };
    var url2 = `${YoutubeUrl}?v=${videoId}`;
    const response = await this.proxy.fetchThroughtProxy(`${url2}`, { headers }, isBrowser());
    const page = await response.text();
    if (page.includes('class="g-recaptcha')) {
      throw new TooManyRequestsError();
    }
    if (!page.includes("playabilityStatus")) {
      throw new VideoUnavailableError();
    }
    return page;
  }
  async fetchMetadata(url2) {
    const videoId = this.getVideoId(url2);
    const page = await this.fetchVideo(videoId);
    const player = match(page, RegexExtractMetadataPlayer);
    const data = match(page, RegexExtractMetadata);
    if (!player || !data) {
      throw new MetricNotAvaible();
    }
    const metadata = { player: JSON.parse(player), data: JSON.parse(data) };
    return metadata;
  }
  /**
   * Get video id of the video for the given url
   * @param url 
   */
  getVideoId(url2) {
    if (url2.length == 11) {
      return url2;
    }
    const rules = [RegexExtractYoutubeVideoIdFromShortUrl, RegexExtractYoutubeVideoId];
    for (const rule of rules) {
      const videoId = match(url2, rule);
      if (!videoId) {
        continue;
      }
      return videoId;
    }
    return url2;
  }
};

// ../youtube-video-core/src/index.ts
var Server = isBrowser() ? null : (init_dist(), __toCommonJS(dist_exports));
var src_default2 = new Core();

// src/transcriptor.ts
var Transcriptor = class extends Core {
  constructor() {
    super();
  }
  /**
   * Fetch transcript from multiple Youtube Video
   * @param url Video url
   * @param languages Languages to fetch
   */
  async getTranscript(url2, languages = ["en"]) {
    if (typeof languages === "string") {
      languages = [languages];
    }
    const transcripts = await this.listTranscripts(url2);
    const filteredTranscriptions = transcripts.getMultiple(languages);
    if (filteredTranscriptions.length == 1) {
      return filteredTranscriptions[0];
    }
    return filteredTranscriptions;
  }
  /**
   * Fetch transcript from one Youtube Video
   * @param urls Video(s) url
   * @param languages Languages to fetch
   */
  async getTranscripts(urls, languages = ["en"]) {
    if (typeof urls === "string") {
      urls = [urls];
    }
    const transcriptions = [];
    for (const url2 of urls) {
      var transcripts = await this.getTranscript(url2, languages);
      if (Array.isArray(transcripts) === false) {
        transcripts = [transcripts];
      }
      for (const transcript of transcripts) {
        transcriptions.push(transcript);
      }
    }
    return transcriptions;
  }
  /**
   * List all transcripts from a Youtube Video
   * @param url Url of the video
   */
  async listTranscripts(url2) {
    const { player } = await this.fetchMetadata(url2);
    ;
    const { captionTracks } = player.captions.playerCaptionsTracklistRenderer;
    const transcripts = [];
    for (const track of captionTracks) {
      const { baseUrl, languageCode, kind } = track;
      const page = await this.fetchXmlTranscript(baseUrl);
      const data = [...page.matchAll(RegexExtractFromXml)].map(([, start, duration, text]) => ({ start: parseFloat(start), duration: parseFloat(duration), text }));
      transcripts.push({ language: languageCode, type: kind == "asr" ? "auto" : "manual", data });
    }
    return new TranscriptionList(transcripts);
  }
  async fetchXmlTranscript(url2) {
    const headers = { "User-Agent": UserAgent, "Accept-Language": "en-US" };
    const response = await fetch(url2, { headers });
    return await response.text();
  }
};

// src/index.ts
var src_default3 = new Transcriptor();
export {
  InvalidLanguageError,
  InvalidVideoUrlError,
  LanguageNotAvailableError,
  TooManyRequestsError,
  TranscriptionDisabledError,
  TranscriptionList,
  Transcriptor,
  VideoUnavailableError,
  src_default3 as default
};
//# sourceMappingURL=index.mjs.map